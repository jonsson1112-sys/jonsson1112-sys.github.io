<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Core Defense: Split Screen & Zoom</title>
    <style>
        body { margin: 0; background: #050505; color: white; font-family: 'Courier New', monospace; overflow: hidden; }
        canvas { display: block; image-rendering: pixelated; }
        #ui { position: absolute; top: 0; left: 0; pointer-events: none; width: 100%; height: 100%; }
        .panel { position: absolute; background: rgba(0,0,0,0.9); padding: 12px; border: 2px solid #555; pointer-events: auto; }
        #editorUI { right: 20px; top: 20px; width: 280px; max-height: 90vh; overflow-y: auto; }
        #statsUI { left: 20px; top: 20px; }
        #msg { color: #ff4444; font-weight: bold; min-height: 20px; font-size: 0.8em; }
        button { cursor: pointer; background: #333; color: white; border: 1px solid #777; padding: 6px; margin: 2px 0; width: 100%; text-align: left; font-size: 12px; }
        button:hover { background: #555; }
        button.active { border-color: #0ff; background: #444; box-shadow: 0 0 8px #0ff; }
        .money-text { color: #5f5; font-size: 1.4em; font-weight: bold; margin: 5px 0; }
        .slider-group { margin: 10px 0; font-size: 11px; border-top: 1px solid #333; padding-top: 5px; }
        input[type=range] { width: 100%; }
        input[disabled] { opacity: 0.4; cursor: not-allowed; }
        .hidden { display: none; }
        .controls-hint { font-size: 10px; color: #aaa; margin-top: 5px; line-height: 1.4; }
        .save-load-buttons { display: flex; gap: 5px; margin-top: 10px; }
        .save-load-buttons button { flex: 1; text-align: center; padding: 8px; }
        #saveBtn { background: #228; }
        #loadBtn { background: #282; }
        .save-status { font-size: 10px; color: #aaa; text-align: center; margin-top: 5px; min-height: 14px; }
        .crate-buttons { display: grid; grid-template-columns: 1fr 1fr; gap: 5px; margin: 10px 0; }
        .crate-buttons button { text-align: center; padding: 8px; font-size: 11px; }
        .crate-pierce { background: #006; border-color: #0ff; }
        .crate-heavy { background: #600; border-color: #f00; }
        .crate-explosive { background: #660; border-color: #ff0; }
        .crate-sand { background: #964; border-color: #da8; }
        .crate-poison { background: #060; border-color: #0f0; }
        .crate-air { background: #404; border-color: #f0f; }
        /* Save slots styles */
        .save-slots-container { margin: 10px 0; border: 1px solid #333; padding: 10px; }
        .save-slot { display: flex; justify-content: space-between; align-items: center; margin: 5px 0; padding: 8px; background: #222; border: 1px solid #444; }
        .save-slot.selected { border-color: #0ff; background: #334; }
        .save-slot-info { flex: 1; }
        .save-slot-name { font-weight: bold; margin-bottom: 2px; }
        .save-slot-details { font-size: 9px; color: #aaa; }
        .save-slot-empty { font-style: italic; color: #666; }
        .save-slot-actions { display: flex; gap: 5px; }
        .save-slot-btn { padding: 3px 8px; font-size: 10px; width: auto; }
        .select-slot-btn { background: #333; }
        .save-slot-btn:hover { background: #555; }
        .save-slot-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px; }
        .save-slot-title { font-weight: bold; }
        .current-slot-display { font-size: 10px; color: #0ff; }
    </style>
</head>
<body>

    <div id="ui">
        <div id="statsUI" class="panel">
            <h2 id="waveDisplay" style="margin:0">WAVE: 1</h2>
            <p class="money-text">$<span id="moneyDisplay">2000</span></p>
            <p style="margin:5px 0">CORE: <span id="coreHP">1000</span> / <span id="maxCoreHP">1000</span> HP</p>
            <div id="msg"></div>
        </div>

        <div id="editorUI" class="panel">
            <h3 style="margin:0 0 10px 0">BUILD MENU</h3>
            <div id="buttons">
                <button id="btn1" onclick="setBrush(1)">Wall ($20)</button>
                <button id="btn2" onclick="setBrush(2)">Health ($50)</button>
                <button id="btn7" onclick="setBrush(7)">Turret ($100)</button>
                <button id="btn8" onclick="setBrush(8)">Farm ($150)</button>
                <button id="btn9" onclick="setBrush(9)">Speed ($120)</button>
                <button id="btn10" onclick="setBrush(10)">Range ($120)</button>
                <button id="btn14" onclick="setBrush(14)">Fly Trap ($80)</button>
            </div>
            
            <div class="slider-group">
                <label>Brush Size: <span id="brushVal">1</span></label>
                <input type="range" id="brushSlider" min="1" max="6" value="1" oninput="brushSize=parseInt(this.value); document.getElementById('brushVal').innerText=this.value">
            </div>

            <div class="slider-group">
                <label>Player Zoom: <span id="pZoomVal">1.0</span>x</label>
                <input type="range" id="pZoomSlider" min="0.4" max="2.0" step="0.1" value="1.0" oninput="playerZoom=parseFloat(this.value); document.getElementById('pZoomVal').innerText=this.value">
            </div>

            <h4 style="margin:15px 0 5px 0">CRATE TYPES</h4>
            <div class="crate-buttons">
                <button class="crate-pierce" onclick="setBrush(3)">Pierce ($80)</button>
                <button class="crate-heavy" onclick="setBrush(4)">Heavy ($100)</button>
                <button class="crate-explosive" onclick="setBrush(5)">Explosive ($90)</button>
                <button class="crate-sand" onclick="setBrush(12)">Sand ($60)</button>
                <button class="crate-poison" onclick="setBrush(13)">Poison ($70)</button>
                <button class="crate-air" onclick="setBrush(15)">Air Gun ($110)</button>
            </div>

            <div id="setupControls">
                <div class="slider-group">
                    <label>Map Width: <span id="widthVal">30</span></label>
                    <input type="range" class="setup-input" id="widthSlider" min="15" max="100" value="30" oninput="updateMapSize()">
                </div>
                <div class="slider-group">
                    <label>Map Height: <span id="heightVal">20</span></label>
                    <input type="range" class="setup-input" id="heightSlider" min="10" max="100" value="20" oninput="updateMapSize()">
                </div>
                <div class="slider-group">
                    <label>Starting Money: <span id="moneyVal">2000</span></label>
                    <input type="range" class="setup-input" id="moneySlider" min="500" max="10000" step="100" value="2000" oninput="updateStartingMoney()">
                </div>
                <div class="slider-group">
                    <label>Core Health: <span id="coreVal">1000</span></label>
                    <input type="range" class="setup-input" id="coreSlider" min="500" max="5000" step="100" value="1000" oninput="updateCoreHealth()">
                </div>
                <div class="slider-group">
                    <label>Difficulty: <span id="diffVal">50</span></label>
                    <input type="range" class="setup-input" id="diffSlider" min="10" max="100000" value="50" oninput="difficulty=parseInt(this.value); document.getElementById('diffVal').innerText=this.value">
                </div>
                <div class="slider-group">
                    <label>Flyer Spawn Chance: <span id="flyerVal">20</span>%</label>
                    <input type="range" class="setup-input" id="flyerSlider" min="0" max="100" value="20" oninput="flyerSpawnChance=parseInt(this.value); document.getElementById('flyerVal').innerText=this.value">
                </div>
            </div>

            <!-- Save Slots Section -->
            <div class="save-slots-container">
                <div class="save-slot-header">
                    <div class="save-slot-title">SAVE SLOTS</div>
                    <div class="current-slot-display">Current: Slot <span id="currentSlotDisplay">1</span></div>
                </div>
                <div id="saveSlots">
                    <!-- Save slots will be generated here -->
                </div>
            </div>

            <div class="save-load-buttons">
                <button id="saveBtn" onclick="saveGame()">üíæ SAVE TO SLOT</button>
                <button id="loadBtn" onclick="loadGame()">üìÇ LOAD FROM SLOT</button>
                <button id="clearBtn" onclick="clearCurrentSlot()">üóëÔ∏è CLEAR SLOT</button>
            </div>
            <div id="saveStatus" class="save-status"></div>

            <button id="startBtn" onclick="startWave()" style="background: #282; font-weight: bold; text-align: center; margin-top: 10px; font-size: 16px; height: 40px;">START WAVE</button>
            <div class="controls-hint">
                P1: WASD+3 | P2: ARROWS+Space<br>
                EDITOR: Arrows: Pan | Scroll: Zoom
            </div>
        </div>
    </div>

    <canvas id="gameCanvas"></canvas>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

let TILE_SIZE = 40;
let MAP_WIDTH = 30;
let MAP_HEIGHT = 20;
let gameState = 'EDITOR', brushType = 1, brushSize = 1, money = 2000, wave = 1, difficulty = 50;
let currentSaveSlot = 1; // Track currently selected slot (1-5)
let flyerSpawnChance = 20; // Percentage chance for flying enemies to spawn

// Cameras
let editCam = { x: 600, y: 400, zoom: 1.0 }; 
let playerZoom = 1.0;

const TILES = { 
    EMPTY: 0, WALL: 1, HEALTH: 2, CORE: 6, TURRET: 7, FARM: 8, 
    UP_SPEED: 9, UP_RANGE: 10, 
    CRATE_PIERCE: 3, CRATE_HEAVY: 4, CRATE_EXPLOSIVE: 5,
    SAND: 12, POISON: 13,
    FLY_TRAP: 14,  // New: Trap that catches flying enemies
    CRATE_AIR: 15   // New: Air gun crate
};

const COSTS = { 
    1: 20, 2: 50, 7: 100, 8: 150, 9: 120, 10: 120,
    3: 80, 4: 100, 5: 90, 12: 60, 13: 70,
    14: 80, 15: 110  // New costs
};

const COLORS = { 
    0: '#111', 1: '#555', 2: '#ff4444', 6: '#00ffff', 7: '#ff8800', 8: '#44ff44', 
    9: '#00ccff', 10: '#ff00ff', 
    3: '#0066cc', 4: '#cc3300', 5: '#cc9900',
    12: '#daa520', 13: '#00aa00',
    14: '#8844aa', 15: '#ff44ff'  // New colors
};

const POWER_COLORS = { 
    'pierce': '#0ff', 'heavy': '#f00', 'explosive': '#ff0',
    'sand': '#da8', 'poison': '#0f0', 'air': '#f0f' 
};

let map = [];
let flowField = [];
let players = [], bullets = [], enemies = [], turrets = [], farms = [], explosions = [], burns = [], sandTraps = [], poisonClouds = [], flyTraps = [], airBullets = [];
let core = { x: 15, y: 10, hp: 1000, maxHp: 1000 };

// Initialize save slots display
function initSaveSlots() {
    const saveSlotsContainer = document.getElementById('saveSlots');
    saveSlotsContainer.innerHTML = '';
    
    for (let i = 1; i <= 5; i++) {
        const slotData = getSaveSlot(i);
        const slotElement = document.createElement('div');
        slotElement.className = `save-slot ${currentSaveSlot === i ? 'selected' : ''}`;
        slotElement.id = `saveSlot${i}`;
        
        let slotInfo = '';
        if (slotData) {
            const saveDate = new Date(slotData.timestamp).toLocaleString();
            slotInfo = `
                <div class="save-slot-info">
                    <div class="save-slot-name">Slot ${i}: Wave ${slotData.wave}</div>
                    <div class="save-slot-details">
                        Money: $${slotData.money} | ${saveDate}
                    </div>
                </div>
            `;
        } else {
            slotInfo = `
                <div class="save-slot-info">
                    <div class="save-slot-name">Slot ${i}</div>
                    <div class="save-slot-details save-slot-empty">(Empty)</div>
                </div>
            `;
        }
        
        slotElement.innerHTML = `
            ${slotInfo}
            <div class="save-slot-actions">
                <button class="save-slot-btn select-slot-btn" onclick="selectSaveSlot(${i})">Select</button>
                <button class="save-slot-btn" onclick="deleteSaveSlot(${i})" style="background: #822;">X</button>
            </div>
        `;
        
        saveSlotsContainer.appendChild(slotElement);
    }
    
    document.getElementById('currentSlotDisplay').textContent = currentSaveSlot;
}

// Select a save slot
function selectSaveSlot(slotNumber) {
    currentSaveSlot = slotNumber;
    initSaveSlots();
    showMessage(`Selected slot ${slotNumber}`, false);
    
    // Update save status display
    const slotData = getSaveSlot(slotNumber);
    if (slotData) {
        const saveDate = new Date(slotData.timestamp).toLocaleString();
        document.getElementById('saveStatus').innerHTML = 
            `Slot ${slotNumber}: Wave ${slotData.wave}, $${slotData.money}<br>Saved: ${saveDate}`;
    } else {
        document.getElementById('saveStatus').innerHTML = 
            `Slot ${slotNumber}: (Empty)`;
    }
}

// Get save slot data
function getSaveSlot(slotNumber) {
    try {
        const savedData = localStorage.getItem(`coreDefenseSave_slot${slotNumber}`);
        return savedData ? JSON.parse(savedData) : null;
    } catch (e) {
        return null;
    }
}

// Save game state to current slot
function saveGame() {
    if (gameState === 'PLAYING') {
        showMessage("Cannot save during wave!", true);
        return;
    }
    
    const gameData = {
        version: '1.3',
        timestamp: Date.now(),
        slot: currentSaveSlot,
        wave: wave,
        money: money,
        map: map,
        core: {
            x: core.x,
            y: core.y,
            hp: core.hp,
            maxHp: core.maxHp
        },
        players: players.map(p => ({
            x: p.x,
            y: p.y,
            id: p.id,
            powerup: p.powerup,
            powerUsage: p.powerUsage
        })),
        turrets: turrets.map(t => ({
            gx: t.gx,
            gy: t.gy,
            health: t.health,
            maxHealth: t.maxHealth
        })),
        farms: farms.map(f => ({
            gx: f.gx,
            gy: f.gy
        })),
        flyTraps: flyTraps.map(ft => ({
            gx: ft.gx,
            gy: ft.gy,
            capturedEnemies: ft.capturedEnemies
        })),
        gameSettings: {
            MAP_WIDTH: MAP_WIDTH,
            MAP_HEIGHT: MAP_HEIGHT,
            difficulty: difficulty,
            flyerSpawnChance: flyerSpawnChance,
            playerZoom: playerZoom,
            editCam: editCam
        }
    };
    
    try {
        localStorage.setItem(`coreDefenseSave_slot${currentSaveSlot}`, JSON.stringify(gameData));
        showMessage(`Game saved to slot ${currentSaveSlot}!`, false);
        
        // Update save slots display
        initSaveSlots();
        
        // Update save status display
        const saveDate = new Date(gameData.timestamp).toLocaleString();
        document.getElementById('saveStatus').innerHTML = 
            `Slot ${currentSaveSlot} saved: Wave ${wave} | Money: $${money}<br>${saveDate}`;
    } catch (e) {
        showMessage("Error saving game: " + e.message, true);
    }
}

// Load game state from current slot
function loadGame() {
    if (gameState === 'PLAYING') {
        showMessage("Cannot load during wave!", true);
        return;
    }
    
    try {
        const slotData = getSaveSlot(currentSaveSlot);
        if (!slotData) {
            showMessage(`Slot ${currentSaveSlot} is empty!`, true);
            return;
        }
        
        // Validate save data
        if (!slotData.version || !slotData.map || !slotData.core) {
            showMessage("Invalid save data in slot!", true);
            return;
        }
        
        // Reset current game state
        bullets = [];
        enemies = [];
        explosions = [];
        burns = [];
        sandTraps = [];
        poisonClouds = [];
        airBullets = [];
        flyTraps = [];
        
        // Load basic game state
        wave = slotData.wave || 1;
        money = slotData.money || 2000;
        
        // Load map
        map = slotData.map;
        MAP_WIDTH = map[0].length;
        MAP_HEIGHT = map.length;
        
        // Update UI sliders
        document.getElementById('widthSlider').value = MAP_WIDTH;
        document.getElementById('heightSlider').value = MAP_HEIGHT;
        document.getElementById('widthVal').innerText = MAP_WIDTH;
        document.getElementById('heightVal').innerText = MAP_HEIGHT;
        
        // Load core
        core.x = slotData.core.x;
        core.y = slotData.core.y;
        core.hp = slotData.core.hp;
        core.maxHp = slotData.core.maxHp || 1000;
        
        // Update core UI sliders
        document.getElementById('coreSlider').value = core.maxHp;
        document.getElementById('moneySlider').value = money;
        document.getElementById('coreVal').innerText = core.maxHp;
        document.getElementById('moneyVal').innerText = money;
        
        // Load players
        players = (slotData.players || []).map(pData => {
            const player = new Player(pData.x, pData.y, pData.id);
            player.powerup = pData.powerup || null;
            player.powerUsage = pData.powerUsage || 0;
            return player;
        });
        
        // If no players in save, create default ones
        if (players.length === 0) {
            players = [
                new Player(core.x * TILE_SIZE, (core.y + 1) * TILE_SIZE, 1),
                new Player(core.x * TILE_SIZE, (core.y - 1) * TILE_SIZE, 2)
            ];
        }
        
        // Load turrets
        turrets = (slotData.turrets || []).map(tData => {
            const turret = new Turret(tData.gx, tData.gy);
            turret.health = tData.health || 100;
            turret.maxHealth = tData.maxHealth || 100;
            return turret;
        });
        
        // Load farms
        farms = slotData.farms || [];
        
        // Load fly traps
        flyTraps = (slotData.flyTraps || []).map(ftData => {
            const flyTrap = new FlyTrap(ftData.gx, ftData.gy);
            flyTrap.capturedEnemies = ftData.capturedEnemies || 0;
            return flyTrap;
        });
        
        // Load game settings
        if (slotData.gameSettings) {
            difficulty = slotData.gameSettings.difficulty || 50;
            flyerSpawnChance = slotData.gameSettings.flyerSpawnChance || 20;
            playerZoom = slotData.gameSettings.playerZoom || 1.0;
            if (slotData.gameSettings.editCam) {
                editCam = slotData.gameSettings.editCam;
            }
            
            document.getElementById('diffSlider').value = difficulty;
            document.getElementById('flyerSlider').value = flyerSpawnChance;
            document.getElementById('pZoomSlider').value = playerZoom;
            document.getElementById('diffVal').innerText = difficulty;
            document.getElementById('flyerVal').innerText = flyerSpawnChance;
            document.getElementById('pZoomVal').innerText = playerZoom;
        }
        
        // Update flow field
        updateFlowField();
        
        // Update UI
        document.getElementById('moneyDisplay').innerText = money;
        document.getElementById('coreHP').innerText = Math.floor(core.hp);
        document.getElementById('maxCoreHP').innerText = core.maxHp;
        document.getElementById('waveDisplay').innerText = "WAVE: " + wave;
        
        // Update save slots display
        initSaveSlots();
        
        // Show save info
        const saveDate = new Date(slotData.timestamp).toLocaleString();
        document.getElementById('saveStatus').innerHTML = 
            `Loaded slot ${currentSaveSlot}: Wave ${wave} | Money: $${money}<br>${saveDate}`;
        
        showMessage(`Game loaded from slot ${currentSaveSlot}!`, false);
        
    } catch (e) {
        showMessage("Error loading game: " + e.message, true);
        console.error("Load error:", e);
    }
}

// Delete a specific save slot
function deleteSaveSlot(slotNumber) {
    if (confirm(`Are you sure you want to delete save slot ${slotNumber}? This cannot be undone!`)) {
        localStorage.removeItem(`coreDefenseSave_slot${slotNumber}`);
        showMessage(`Slot ${slotNumber} deleted!`, false);
        initSaveSlots();
        
        // If we deleted the current slot, update status
        if (slotNumber === currentSaveSlot) {
            document.getElementById('saveStatus').innerHTML = 
                `Slot ${currentSaveSlot}: (Empty)`;
        }
    }
}

// Clear current save slot
function clearCurrentSlot() {
    deleteSaveSlot(currentSaveSlot);
}

// Check for existing saves on load
window.addEventListener('load', function() {
    // Initialize save slots display
    initSaveSlots();
    
    // Check if any slot has data and display the first available
    for (let i = 1; i <= 5; i++) {
        const slotData = getSaveSlot(i);
        if (slotData) {
            const saveDate = new Date(slotData.timestamp).toLocaleString();
            document.getElementById('saveStatus').innerHTML = 
                `Slot ${i}: Wave ${slotData.wave}, $${slotData.money}<br>Saved: ${saveDate}`;
            break;
        }
    }
});

function showMessage(text, isError) {
    const msg = document.getElementById('msg');
    msg.textContent = text;
    msg.style.color = isError ? '#ff4444' : '#44ff44';
    setTimeout(() => {
        msg.textContent = '';
    }, 3000);
}

function updateStartingMoney() {
    if (wave > 1 || gameState === 'PLAYING') return;
    money = parseInt(document.getElementById('moneySlider').value);
    document.getElementById('moneyVal').innerText = money;
    document.getElementById('moneyDisplay').innerText = money;
}

function updateCoreHealth() {
    if (wave > 1 || gameState === 'PLAYING') return;
    core.maxHp = parseInt(document.getElementById('coreSlider').value);
    core.hp = core.maxHp;
    document.getElementById('coreVal').innerText = core.maxHp;
    document.getElementById('maxCoreHP').innerText = core.maxHp;
    document.getElementById('coreHP').innerText = core.hp;
}

function initMap(resetCamera = false) {
    map = Array(MAP_HEIGHT).fill().map(() => Array(MAP_WIDTH).fill(0));
    core.x = Math.floor(MAP_WIDTH / 2);
    core.y = Math.floor(MAP_HEIGHT / 2);
    map[core.y][core.x] = TILES.CORE;
    if (resetCamera) { 
        editCam.x = core.x * TILE_SIZE; 
        editCam.y = core.y * TILE_SIZE; 
        editCam.zoom = 1.0;
    }
    players = [
        new Player(core.x * TILE_SIZE, (core.y + 1) * TILE_SIZE, 1),
        new Player(core.x * TILE_SIZE, (core.y - 1) * TILE_SIZE, 2)
    ];
    turrets = [];
    farms = [];
    flyTraps = [];
    updateFlowField();
}

function updateMapSize() {
    if (wave > 1 || gameState === 'PLAYING') return;
    MAP_WIDTH = parseInt(document.getElementById('widthSlider').value);
    MAP_HEIGHT = parseInt(document.getElementById('heightSlider').value);
    document.getElementById('widthVal').innerText = MAP_WIDTH;
    document.getElementById('heightVal').innerText = MAP_HEIGHT;
    initMap(false);
}

function resize() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; }
window.addEventListener('resize', resize); resize();

const keys = {};
let isMouseDown = false, mouseBtn = -1;
window.onkeydown = (e) => keys[e.code] = true;
window.onkeyup = (e) => keys[e.code] = false;

canvas.addEventListener('wheel', (e) => {
    if (gameState === 'EDITOR') {
        e.preventDefault();
        const delta = e.deltaY > 0 ? 0.9 : 1.1;
        editCam.zoom = Math.min(Math.max(editCam.zoom * delta, 0.1), 4.0);
    }
}, { passive: false });

function setBrush(t) { 
    brushType = t; 
    document.querySelectorAll('#buttons button').forEach(b=>b.classList.remove('active')); 
    document.querySelectorAll('.crate-buttons button').forEach(b=>b.classList.remove('active'));
    
    if(document.getElementById('btn'+t)) {
        document.getElementById('btn'+t).classList.add('active');
    }
    
    // Also activate crate buttons
    const crateMap = {3: 'Pierce', 4: 'Heavy', 5: 'Explosive', 12: 'Sand', 13: 'Poison', 15: 'Air'};
    if(crateMap[t]) {
        const crateButtons = document.querySelectorAll('.crate-buttons button');
        crateButtons.forEach(btn => {
            if(btn.textContent.includes(crateMap[t])) {
                btn.classList.add('active');
            }
        });
    }
}
setBrush(1);

function updateFlowField() {
    let dist = Array(MAP_HEIGHT).fill().map(() => Array(MAP_WIDTH).fill(Infinity));
    let queue = [{x: core.x, y: core.y, d: 0}];
    dist[core.y][core.x] = 0;
    while(queue.length > 0) {
        let {x, y, d} = queue.shift();
        for(let [dx, dy] of [[0,1],[0,-1],[1,0],[-1,0]]) {
            let nx = x + dx, ny = y + dy;
            if(nx>=0 && nx<MAP_WIDTH && ny>=0 && ny<MAP_HEIGHT) {
                if(map[ny][nx] !== TILES.WALL && map[ny][nx] !== TILES.TURRET && dist[ny][nx] === Infinity) {
                    dist[ny][nx] = d + 1;
                    queue.push({x: nx, y: ny, d: d+1});
                }
            }
        }
    }
    flowField = dist;
}

function placeAt(tx, ty, isDelete) {
    for(let i=0; i<brushSize; i++) {
        for(let j=0; j<brushSize; j++) {
            let cx = tx + i, cy = ty + j;
            if(cx < 0 || cx >= MAP_WIDTH || cy < 0 || cy >= MAP_HEIGHT) continue;
            if(isDelete) {
                if(map[cy][cx] === TILES.TURRET) turrets = turrets.filter(t=>t.gx!==cx||t.gy!==cy);
                if(map[cy][cx] === TILES.FARM) farms = farms.filter(f=>f.gx!==cx||f.gy!==cy);
                if(map[cy][cx] === TILES.FLY_TRAP) flyTraps = flyTraps.filter(ft=>ft.gx!==cx||ft.gy!==cy);
                if(map[cy][cx] !== TILES.CORE) map[cy][cx] = 0;
            } else if (map[cy][cx] === 0 && money >= COSTS[brushType]) {
                map[cy][cx] = brushType;
                updateFlowField();
                const spawns = [{x:0, y:0}, {x:MAP_WIDTH-1, y:0}, {x:0, y:MAP_HEIGHT-1}];
                if(spawns.every(s => flowField[s.y][s.x] !== Infinity)) {
                    money -= COSTS[brushType];
                    if(brushType === 7) turrets.push(new Turret(cx, cy));
                    if(brushType === 8) farms.push({gx: cx, gy: cy});
                    if(brushType === 14) flyTraps.push(new FlyTrap(cx, cy));
                } else { 
                    map[cy][cx] = 0; 
                    updateFlowField(); 
                    showMessage("Blocking enemy path!", true);
                }
            }
        }
    }
    document.getElementById('moneyDisplay').innerText = money;
}

function handleMouseMove(e) {
    if (gameState !== 'EDITOR') return;
    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;
    const tx = Math.floor(((mx - canvas.width/2) / editCam.zoom + editCam.x) / TILE_SIZE);
    const ty = Math.floor(((my - canvas.height/2) / editCam.zoom + editCam.y) / TILE_SIZE);
    placeAt(tx, ty, mouseBtn === 2);
}

canvas.onmousedown = (e) => { isMouseDown = true; mouseBtn = e.button; handleMouseMove(e); };
window.onmouseup = () => isMouseDown = false;
canvas.onmousemove = (e) => { if(isMouseDown) handleMouseMove(e); };
canvas.oncontextmenu = (e) => e.preventDefault();

class Player {
    constructor(x, y, id) { 
        this.x = x; this.y = y; this.id = id; this.angle = 0; this.cooldown = 0; 
        this.powerup = null; this.powerUsage = 0;
    }
    update() {
        let m=0, s=0, r=0; 
        const shootKey = this.id === 1 ? 'Digit3' : 'Space';
        if (this.id === 1) { 
            if(keys['KeyW'])m=1; if(keys['KeyS'])m=-1; if(keys['KeyA'])r=-1; if(keys['KeyD'])r=1; if(keys['KeyQ'])s=-1; if(keys['KeyE'])s=1; 
        } else { 
            if(keys['ArrowUp'])m=1; if(keys['ArrowDown'])m=-1; if(keys['ArrowLeft'])r=-1; if(keys['ArrowRight'])r=1; if(keys['KeyN'])s=-1; if(keys['KeyM'])s=1; 
        }
        
        let tx = Math.floor(this.x/TILE_SIZE), ty = Math.floor(this.y/TILE_SIZE);
        if(tx >= 0 && tx < MAP_WIDTH && ty >= 0 && ty < MAP_HEIGHT) {
            const tile = map[ty][tx];
            
            // Check for crate types
            if(tile >= 3 && tile <= 5 && !this.powerup) {
                map[ty][tx] = 0;
                if(tile === TILES.CRATE_PIERCE) this.powerup = 'pierce';
                else if(tile === TILES.CRATE_HEAVY) this.powerup = 'heavy';
                else if(tile === TILES.CRATE_EXPLOSIVE) this.powerup = 'explosive';
                this.powerUsage = 5;
                if(tile === TILES.CRATE_EXPLOSIVE) this.powerUsage = 1;
            }
            // Check for air gun crate
            else if(tile === TILES.CRATE_AIR && !this.powerup) {
                map[ty][tx] = 0;
                this.powerup = 'air';
                this.powerUsage = 8; // More shots for air gun
            }
            // Check for sand or poison traps
            else if(tile === TILES.SAND) {
                // Sand slows player
                m *= 0.5;
                s *= 0.5;
                r *= 0.5;
            }
            else if(tile === TILES.POISON) {
                // Poison damages player
                core.hp -= 0.5;
            }
            else if(tile === TILES.HEALTH) {
                map[ty][tx] = 0; 
                core.hp = Math.min(core.maxHp, core.hp + 150);
            }
        }
        
        let spd = 4 + (getProximityBoost(tx, ty, TILES.UP_SPEED) * 4);
        this.angle += r * 0.1;
        const vx = (Math.cos(this.angle)*m + Math.cos(this.angle+Math.PI/2)*s)*spd;
        const vy = (Math.sin(this.angle)*m + Math.sin(this.angle+Math.PI/2)*s)*spd;
        if(!getCol(this.x+vx, this.y)) this.x+=vx; 
        if(!getCol(this.x, this.y+vy)) this.y+=vy;
        
        if (keys[shootKey] && this.cooldown <= 0) {
            this.shoot();
            if(this.powerup) { 
                this.powerUsage--; 
                if(this.powerUsage <= 0) this.powerup = null; 
            }
            this.cooldown = 10;
        }
        if(this.cooldown > 0) this.cooldown--;
    }
    
    shoot() {
        if(this.powerup === 'air') {
            // Air gun shoots special air bullets that are effective against flying enemies
            const angle = this.angle;
            const speed = 12;
            airBullets.push(new AirBullet(
                this.x, this.y,
                Math.cos(angle) * speed,
                Math.sin(angle) * speed
            ));
        } else {
            let count = (this.powerup === 'heavy') ? 1 : 3;
            let spread = (this.powerup === 'heavy') ? 0 : 0.2;
            
            for(let i=0; i<count; i++) {
                const angle = this.angle + (i - (count-1)/2) * spread;
                const speed = 10;
                
                if(this.powerup === 'sand') {
                    bullets.push(new Bullet(
                        this.x, this.y,
                        Math.cos(angle) * speed * 0.7,
                        Math.sin(angle) * speed * 0.7,
                        'sand'
                    ));
                } else if(this.powerup === 'poison') {
                    bullets.push(new Bullet(
                        this.x, this.y,
                        Math.cos(angle) * speed,
                        Math.sin(angle) * speed,
                        'poison'
                    ));
                } else {
                    bullets.push(new Bullet(
                        this.x, this.y,
                        Math.cos(angle) * speed,
                        Math.sin(angle) * speed,
                        this.powerup
                    ));
                }
            }
        }
    }
}

class AirBullet {
    constructor(x, y, vx, vy) {
        this.x = x;
        this.y = y;
        this.vx = vx;
        this.vy = vy;
        this.type = 'air';
        this.damage = 60; // High damage against flying enemies
        this.life = 100;
        this.radius = 6;
        this.pierceCount = 0;
        this.maxPierce = 3; // Can pierce multiple flying enemies
    }
    
    update() {
        this.x += this.vx;
        this.y += this.vy;
        this.life--;
        
        if(this.life <= 0) return false;
        
        // Air bullets can go through walls
        if(this.x < 0 || this.x > MAP_WIDTH * TILE_SIZE || this.y < 0 || this.y > MAP_HEIGHT * TILE_SIZE) {
            return false;
        }
        
        // Check for enemy collisions (prioritize flying enemies)
        for(let j = enemies.length-1; j >= 0; j--) {
            let en = enemies[j];
            if(en.type !== 'flyer') continue; // Air bullets only hit flying enemies
            
            const dist = Math.hypot(this.x - en.x, this.y - en.y);
            const hitRadius = this.radius + 8; // Flying enemies are smaller
            
            if(dist < hitRadius) {
                en.health -= this.damage * (1 + this.pierceCount * 0.3); // Damage increases with pierce
                this.pierceCount++;
                
                if(this.pierceCount >= this.maxPierce) {
                    return false;
                }
            }
        }
        
        return true;
    }
    
    draw() {
        // Draw air bullet with swirling effect
        ctx.fillStyle = POWER_COLORS.air;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fill();
        
        // Swirling effect
        const time = Date.now() * 0.01;
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 1;
        ctx.beginPath();
        for(let i = 0; i < 3; i++) {
            const angle = time + (i * Math.PI * 2 / 3);
            const swirlX = this.x + Math.cos(angle) * 4;
            const swirlY = this.y + Math.sin(angle) * 4;
            ctx.moveTo(this.x, this.y);
            ctx.lineTo(swirlX, swirlY);
        }
        ctx.stroke();
        
        // Show pierce count
        if(this.pierceCount > 0) {
            ctx.fillStyle = '#fff';
            ctx.font = '9px Courier New';
            ctx.textAlign = 'center';
            ctx.fillText(`+${this.pierceCount}`, this.x, this.y - 12);
        }
    }
}

class Bullet {
    constructor(x, y, vx, vy, type) {
        this.x = x;
        this.y = y;
        this.vx = vx;
        this.vy = vy;
        this.type = type || 'normal';
        this.pierceCount = 0;
        this.maxPierce = (type === 'pierce') ? 5 : 1;
        this.damage = this.getDamage();
        this.life = this.getLife();
        this.exploded = false;
        this.radius = this.getRadius();
    }
    
    getDamage() {
        switch(this.type) {
            case 'heavy': return 200;
            case 'pierce': return 35;
            case 'explosive': return 50;
            case 'sand': return 10;
            case 'poison': return 20;
            default: return 35; // Turret bullets
        }
    }
    
    getLife() {
        switch(this.type) {
            case 'pierce': return 200;
            case 'sand': return 100;
            case 'poison': return 150;
            default: return 120; // Other bullets
        }
    }
    
    getRadius() {
        switch(this.type) {
            case 'heavy': return 8;
            case 'sand': return 5;
            case 'poison': return 6;
            default: return 4;
        }
    }
    
    update() {
        this.x += this.vx;
        this.y += this.vy;
        this.life--;
        
        if(this.life <= 0) {
            this.onLifeEnd();
            return false;
        }
        
        // Check for wall collision (bullets don't hit flying enemies with walls)
        if(getCol(this.x, this.y, true)) {
            this.onWallHit();
            return false;
        }
        
        // Check for enemy collisions (skip flying enemies for regular bullets)
        let hitEnemy = false;
        for(let j = enemies.length-1; j >= 0; j--) {
            let en = enemies[j];
            if(en.type === 'flyer') continue; // Regular bullets don't hit flying enemies
            
            const dist = Math.hypot(this.x - en.x, this.y - en.y);
            const hitRadius = this.radius + (en.type === 'tank' ? 16 : 10);
            
            if(dist < hitRadius) {
                this.onEnemyHit(en, dist);
                hitEnemy = true;
                
                if(this.type === 'explosive' && !this.exploded) {
                    createExplosion(this.x, this.y);
                    this.exploded = true;
                    return false;
                }
                
                if(this.type !== 'pierce' || this.pierceCount >= this.maxPierce) {
                    return false;
                }
            }
        }
        
        return true;
    }
    
    onLifeEnd() {
        if(this.type === 'sand') {
            sandTraps.push({
                x: this.x,
                y: this.y,
                radius: 60,
                duration: 180,
                maxDuration: 180
            });
        } else if(this.type === 'poison') {
            poisonClouds.push({
                x: this.x,
                y: this.y,
                radius: 80,
                duration: 120,
                maxDuration: 120,
                damage: 5
            });
        }
    }
    
    onWallHit() {
        if(this.type === 'explosive' && !this.exploded) {
            createExplosion(this.x, this.y);
        }
    }
    
    onEnemyHit(enemy, distance) {
        let damageMultiplier = 1 + (this.pierceCount * 0.5);
        let finalDamage = this.damage * damageMultiplier;
        
        if(this.type === 'sand') {
            enemy.speed *= 0.5;
            enemy.slowDuration = 60;
        } else if(this.type === 'poison') {
            enemy.poisoned = true;
            enemy.poisonDuration = 90;
            enemy.poisonDamage = 2;
        }
        
        enemy.health -= finalDamage;
        this.pierceCount++;
    }
    
    draw() {
        ctx.fillStyle = POWER_COLORS[this.type] || '#fff';
        
        if(this.type === 'pierce') {
            let size = 6 + (this.pierceCount * 2);
            ctx.beginPath();
            ctx.arc(this.x, this.y, size, 0, Math.PI * 2);
            ctx.fill();
            
            if(this.pierceCount > 0) {
                ctx.fillStyle = '#fff';
                ctx.font = '10px Courier New';
                ctx.fillText(`x${(1 + this.pierceCount * 0.5).toFixed(1)}`, this.x - 10, this.y - 15);
            }
        } else if(this.type === 'sand') {
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#da8';
            for(let i = 0; i < 3; i++) {
                const offset = (i - 1) * 2;
                ctx.fillRect(this.x + offset - 1, this.y - 1, 2, 2);
            }
        } else if(this.type === 'poison') {
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#0f0';
            ctx.beginPath();
            ctx.arc(this.x - 2, this.y - 2, 2, 0, Math.PI * 2);
            ctx.arc(this.x + 3, this.y + 1, 1.5, 0, Math.PI * 2);
            ctx.fill();
        } else {
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
            ctx.fill();
        }
    }
}

class FlyTrap {
    constructor(gx, gy) {
        this.gx = gx;
        this.gy = gy;
        this.capturedEnemies = 0;
        this.maxCapacity = 3;
        this.cooldown = 0;
        this.range = 150; // Range to capture flying enemies
    }
    
    update() {
        if(this.cooldown > 0) {
            this.cooldown--;
            return;
        }
        
        // Check for flying enemies in range
        for(let i = enemies.length-1; i >= 0; i--) {
            let en = enemies[i];
            if(en.type !== 'flyer') continue;
            
            const trapX = this.gx * TILE_SIZE + 20;
            const trapY = this.gy * TILE_SIZE + 20;
            const dist = Math.hypot(en.x - trapX, en.y - trapY);
            
            if(dist < this.range) {
                // Damage the flying enemy
                const damage = 10; // Damage per tick
                en.health -= damage;
                
                // Cooldown after damaging
                this.cooldown = 15 / getProximityBoost(this.gx, this.gy, TILES.UP_SPEED);;
                break;
            }
        }
    }
    
    draw() {
        const x = this.gx * TILE_SIZE;
        const y = this.gy * TILE_SIZE;
        const centerX = x + TILE_SIZE/2;
        const centerY = y + TILE_SIZE/2;
        
        // Draw trap base
        ctx.fillStyle = COLORS[14];
        ctx.fillRect(x, y, TILE_SIZE-1, TILE_SIZE-1);
        
        // Draw trap pattern
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(x + 5, y + 5);
        ctx.lineTo(x + TILE_SIZE - 5, y + TILE_SIZE - 5);
        ctx.moveTo(x + TILE_SIZE - 5, y + 5);
        ctx.lineTo(x + 5, y + TILE_SIZE - 5);
        ctx.stroke();
        
        // Draw captured enemies indicator
        if(this.capturedEnemies > 0) {
            ctx.fillStyle = '#f0f';
            ctx.font = '12px Courier New';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(`${this.capturedEnemies}`, centerX, centerY);
        }
        
        // Draw range indicator when active
        if(this.cooldown <= 0 && this.capturedEnemies < this.maxCapacity) {
            ctx.strokeStyle = 'rgba(255, 0, 255, 0.2)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.arc(centerX, centerY, this.range, 0, Math.PI * 2);
            ctx.stroke();
        }
    }
}

class Enemy {
    constructor(x, y, type) { 
        this.x = x; this.y = y; this.type = type;
        
        // Different stats for flying enemies
        if(type === 'flyer') {
            this.health = 30 + (wave * wave * 5);
            this.speed = 2.5 + (wave * 0.2);
            this.baseSpeed = this.speed;
            this.altitude = 50 + Math.random() * 50; // Flying height
            this.flapPhase = Math.random() * Math.PI * 2;
        } else {
            this.health = type === 'tank' ? 200+(wave*wave*100) : 40+(wave*wave*10);
            this.speed = type === 'scout' ? 3.5 : (type === 'tank' ? 1.2 + 0.2*wave : 2.0*wave);
            this.baseSpeed = this.speed;
            this.altitude = 0; // Ground enemies
        }
        
        this.maxHealth = this.health;
        this.damageDealt = 0;
        this.slowDuration = 0;
        this.poisoned = false;
        this.poisonDuration = 0;
        this.poisonDamage = 0;
        this.targetType = this.chooseTarget();
    }
    
    chooseTarget() {
        const targets = ['core', 'player', 'turret'];
        const weights = [0.5, 0.3, 0.2];
        let rnd = Math.random();
        let sum = 0;
        for(let i = 0; i < targets.length; i++) {
            sum += weights[i];
            if(rnd <= sum) return targets[i];
        }
        return 'core';
    }
    
    update() {
        // Update status effects
        if(this.slowDuration > 0) {
            this.slowDuration--;
            this.speed = this.baseSpeed * 0.5;
        } else {
            this.speed = this.baseSpeed;
        }
        
        if(this.poisoned && this.poisonDuration > 0) {
            this.poisonDuration--;
            this.health -= this.poisonDamage;
            if(this.poisonDuration <= 0) {
                this.poisoned = false;
            }
        }
        
        // Check for burn damage
        burns.forEach(burn => {
            if(Math.hypot(this.x - burn.x, this.y - burn.y) < burn.radius) {
                this.health -= burn.damage;
                burn.duration--;
            }
        });
        
        // Check for sand traps (only affect ground enemies)
        if(this.type !== 'flyer') {
            sandTraps.forEach(sand => {
                if(Math.hypot(this.x - sand.x, this.y - sand.y) < sand.radius) {
                    this.speed = this.baseSpeed * 0.3;
                    if(!this.slowDuration) this.slowDuration = 30;
                }
            });
            
            // Check for map poison tiles
            let tx = Math.floor(this.x/TILE_SIZE), ty = Math.floor(this.y/TILE_SIZE);
            if(tx >= 0 && tx < MAP_WIDTH && ty >= 0 && ty < MAP_HEIGHT) {
                if(map[ty][tx] === TILES.POISON) {
                    this.health -= 5;
                } else if(map[ty][tx] === TILES.SAND) {
                    this.speed = this.baseSpeed * 0.4;
                    if(!this.slowDuration) this.slowDuration = 30;
                }
            }
        }
        
        // Check for poison clouds
        poisonClouds.forEach(poison => {
            if(Math.hypot(this.x - poison.x, this.y - poison.y) < poison.radius) {
                this.health -= poison.damage;
                if(!this.poisoned) {
                    this.poisoned = true;
                    this.poisonDuration = 60;
                    this.poisonDamage = 3;
                }
            }
        });
        
        let targetX, targetY;
        
        // AI: Choose target based on targetType
        targetX = core.x * TILE_SIZE + 20;
        targetY = core.y * TILE_SIZE + 20;
        switch(this.targetType) {
            case 'core':
                targetX = core.x * TILE_SIZE + 20;
                targetY = core.y * TILE_SIZE + 20;
                break;
            case 'player':
                let closestDist = Infinity;
                players.forEach(p => {
                    let dist = Math.hypot(this.x - p.x, this.y - p.y);
                    if(dist < closestDist) {
                        closestDist = dist;
                        targetX = p.x;
                        targetY = p.y;
                    }
                });
                break;
            case 'turret':
                let closestTurret = null;
                turrets.forEach(t => {
                    let dist = Math.hypot(this.x - (t.gx * TILE_SIZE + 20), this.y - (t.gy * TILE_SIZE + 20));
                    if(dist < 300) {
                        if(!closestTurret || dist < closestTurret.dist) {
                            closestTurret = {x: t.gx * TILE_SIZE + 20, y: t.gy * TILE_SIZE + 20, dist};
                        }
                    }
                });
                if(closestTurret) {
                    targetX = closestTurret.x;
                    targetY = closestTurret.y;
                } else {
                    targetX = core.x * TILE_SIZE + 20;
                    targetY = core.y * TILE_SIZE + 20;
                }
                break;
        }
        
        // Movement logic - flying enemies ignore walls
        if(this.type === 'flyer') {
            // Fly directly toward target, ignoring obstacles
            const angle = Math.atan2(targetY - this.y, targetX - this.x);
            this.x += Math.cos(angle) * this.speed;
            this.y += Math.sin(angle) * this.speed;
            
            // Add slight hovering/flapping motion
            this.flapPhase += 0.1;
            const hoverY = Math.sin(this.flapPhase) * 3;
        } else {
            // Ground enemy pathfinding
            let tx = Math.floor(this.x/TILE_SIZE);
            let ty = Math.floor(this.y/TILE_SIZE);
            let bestD = flowField[ty] ? flowField[ty][tx] : Infinity;
            let moveX = 0, moveY = 0;
            
            if(Math.random() < 0.05) {
                moveX = (Math.random() - 0.5) * 2;
                moveY = (Math.random() - 0.5) * 2;
            } else {
                for(let [dx, dy] of [[0,1],[0,-1],[1,0],[-1,0]]) {
                    let nx = tx+dx, ny = ty+dy;
                    if(flowField[ny] && flowField[ny][nx] < bestD) { 
                        bestD = flowField[ny][nx]; 
                        moveX = dx; 
                        moveY = dy; 
                    }
                }
            }
            
            this.x += moveX * this.speed;
            this.y += moveY * this.speed;
        }
        
        // Deal damage to target
        let damage = this.type === 'tank' ? 1.5 : (this.type === 'flyer' ? 0.3 : 0.4);
        if(Math.hypot(this.x - targetX, this.y - targetY) < 35) {
            if(this.targetType === 'core') {
                core.hp -= damage;
                this.damageDealt += damage;
            } else if(this.targetType === 'turret') {
                turrets.forEach(t => {
                    if(Math.hypot(this.x - (t.gx * TILE_SIZE + 20), this.y - (t.gy * TILE_SIZE + 20)) < 35) {
                        t.health = (t.health || 100) - damage;
                        this.damageDealt += damage;
                    }
                });
            }
        }
        
        if(this.targetType === 'turret' && Math.random() < 0.01) {
            this.targetType = this.chooseTarget();
        }
    }
    
    draw() {
        const healthPercent = this.health / this.maxHealth;
        
        if(this.type === 'flyer') {
            // Draw flying enemy
            const time = Date.now() * 0.001;
            const flap = Math.sin(time * 10 + this.flapPhase) * 3;
            
            // Draw wings
            ctx.fillStyle = '#a0f';
            ctx.beginPath();
            // Left wing
            ctx.moveTo(this.x - 12, this.y + flap);
            ctx.lineTo(this.x - 25, this.y - 5 + flap);
            ctx.lineTo(this.x - 12, this.y - 10 + flap);
            ctx.closePath();
            ctx.fill();
            
            // Right wing
            ctx.beginPath();
            ctx.moveTo(this.x + 12, this.y + flap);
            ctx.lineTo(this.x + 25, this.y - 5 + flap);
            ctx.lineTo(this.x + 12, this.y - 10 + flap);
            ctx.closePath();
            ctx.fill();
            
            // Draw body
            ctx.fillStyle = this.poisoned ? '#0f0' : '#f0f';
            ctx.beginPath();
            ctx.ellipse(this.x, this.y, 8, 5, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw eyes
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(this.x - 3, this.y - 2, 2, 0, Math.PI * 2);
            ctx.arc(this.x + 3, this.y - 2, 2, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw altitude indicator
            ctx.strokeStyle = '#f0f';
            ctx.lineWidth = 1;
            ctx.setLineDash([2, 2]);
            ctx.beginPath();
            ctx.moveTo(this.x, this.y);
            ctx.lineTo(this.x, this.y - this.altitude);
            ctx.stroke();
            ctx.setLineDash([]);
            
        } else {
            // Draw ground enemy
            let bodyColor = this.type === 'tank' ? '#f00' : '#f0f';
            if(this.poisoned) bodyColor = '#0f0';
            if(this.slowDuration > 0) bodyColor = '#da8';
            
            ctx.fillStyle = bodyColor;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.type === 'tank' ? 16 : 10, 0, Math.PI * 2);
            ctx.fill();
            
            if(this.poisoned) {
                ctx.strokeStyle = '#0f0';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(this.x, this.y, (this.type === 'tank' ? 18 : 12), 0, Math.PI * 2);
                ctx.stroke();
            }
            
            if(this.slowDuration > 0) {
                ctx.strokeStyle = '#da8';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.arc(this.x, this.y, (this.type === 'tank' ? 20 : 14), 0, Math.PI * 2);
                ctx.stroke();
                ctx.setLineDash([]);
            }
        }
        
        // Health bar above enemy
        const barWidth = this.type === 'flyer' ? 20 : 30;
        const barHeight = 3;
        const barX = this.x - barWidth/2;
        const barY = this.y - (this.type === 'flyer' ? 30 : 25);
        
        ctx.fillStyle = '#f00';
        ctx.fillRect(barX, barY, barWidth, barHeight);
        ctx.fillStyle = '#0f0';
        ctx.fillRect(barX, barY, barWidth * healthPercent, barHeight);
        
        // Target indicator for ground enemies only
        if(this.type !== 'flyer') {
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.arc(this.x, this.y, 12, 0, Math.PI * 2);
            ctx.stroke();
        }
    }
}

class Turret {
    constructor(gx, gy) { 
        this.gx = gx; this.gy = gy; 
        this.cd = 0; 
        this.health = 100;
        this.maxHealth = 100;
    }
    
    update() {
        if(this.cd > 0) { this.cd--; return; }
        if(this.health <= 0) return;
        
        const posX = this.gx * TILE_SIZE + 20;
        const posY = this.gy * TILE_SIZE + 20;
        
        let rangeBoost = getProximityBoost(this.gx, this.gy, TILES.UP_RANGE);
        let range = 300 + rangeBoost * 300;
        
        // Turrets only target ground enemies
        let target = enemies.reduce((best, en) => {
            if(en.type === 'flyer') return best; // Skip flying enemies
            
            let dist = Math.hypot(en.x - posX, en.y - posY);
            if(dist < range) {
                let score = en.damageDealt * 2;
                if(!best || score > best.score) {
                    return {enemy: en, dist, score};
                }
            }
            return best;
        }, null);
        
        if(target) {
            let a = Math.atan2(target.enemy.y - posY, target.enemy.x - posX);
            bullets.push(new Bullet(posX, posY, Math.cos(a) * 12, Math.sin(a) * 12, null));
            this.cd = 30;
        }
    }
    
    draw() {
        if(this.health < this.maxHealth) {
            const barWidth = 30;
            const barHeight = 4;
            const barX = this.gx * TILE_SIZE + 5;
            const barY = this.gy * TILE_SIZE - 10;
            
            ctx.fillStyle = '#f00';
            ctx.fillRect(barX, barY, barWidth, barHeight);
            ctx.fillStyle = '#0f0';
            ctx.fillRect(barX, barY, barWidth * (this.health / this.maxHealth), barHeight);
        }
    }
}

function getCol(x,y,isB=false) {
    let tx=Math.floor(x/TILE_SIZE), ty=Math.floor(y/TILE_SIZE);
    if(tx<0||tx>=MAP_WIDTH||ty<0||ty>=MAP_HEIGHT) return true;
    let t = map[ty][tx];
    return isB ? (t === 1) : (t === 1 || t === 6 || t === 7);
}

function getProximityBoost(gx, gy, tileType) {
    let count = 0;
    for(let y = gy-2; y <= gy+2; y++) 
        for(let x = gx-2; x <= gx+2; x++) 
            if(x>=0 && x<MAP_WIDTH && y>=0 && y<MAP_HEIGHT && map[y][x] === tileType) count++;
    return Math.min(count, 99999) / 4;
}

function createExplosion(x, y) {
    explosions.push({x, y, r: 0, maxR: 100});
    burns.push({
        x, y, 
        radius: 80, 
        damage: 5, 
        duration: 120,
        maxDuration: 120,
        color: '#ff5500'
    });
}

function startWave() {
    if (core.hp < core.maxHp / 2) core.hp = core.maxHp / 2;
    if (wave === 1) document.querySelectorAll('.setup-input').forEach(i => i.disabled = true);
    gameState = 'PLAYING'; 
    document.getElementById('editorUI').classList.add('hidden');
    updateFlowField();
    
    let count = 10 + (wave * difficulty / 100);
    for(let i=0; i<count; i++) {
        let side = Math.floor(Math.random()*4), rx, ry;
        if(side===0) { rx=0; ry=Math.random()*MAP_HEIGHT; }
        else if(side===1) { rx=MAP_WIDTH-1; ry=Math.random()*MAP_HEIGHT; }
        else if(side===2) { rx=Math.random()*MAP_WIDTH; ry=0; }
        else { rx=Math.random()*MAP_WIDTH; ry=MAP_HEIGHT-1; }
        
        let type = Math.random();
        let enemyType;
        
        // Chance to spawn flying enemy
        if(Math.random() * 100 < flyerSpawnChance) {
            enemyType = 'flyer';
        } else {
            enemyType = type < 0.1 ? 'scout' : (type < 0.3 ? 'tank' : 'norm');
        }
        
        enemies.push(new Enemy(rx*TILE_SIZE+20, ry*TILE_SIZE+20, enemyType));
    }
}

function update() {
    if(gameState === 'EDITOR') {
        let camSpd = 8 / editCam.zoom;
        if(keys['ArrowUp']) editCam.y -= camSpd;
        if(keys['ArrowDown']) editCam.y += camSpd;
        if(keys['ArrowLeft']) editCam.x -= camSpd;
        if(keys['ArrowRight']) editCam.x += camSpd;
    }
    
    if(gameState !== 'PLAYING') return;
    
    // Update all entities
    players.forEach(p=>p.update()); 
    turrets.forEach(t=>t.update());
    flyTraps.forEach(ft=>ft.update());
    
    // Update air bullets
    for(let i = airBullets.length-1; i >= 0; i--) {
        if(!airBullets[i].update()) {
            airBullets.splice(i,1);
        }
    }
    
    // Update enemies and remove dead ones
    enemies.forEach((en, i) => { 
        en.update(); 
        if(en.health <= 0) { 
            enemies.splice(i,1); 
            // money += en.type === 'tank' ? 50 : (en.type === 'flyer' ? 30 : 15); 
            document.getElementById('moneyDisplay').innerText = money; 
        }
    });
    
    // Update bullets
    for(let i = bullets.length-1; i >= 0; i--) {
        if(!bullets[i].update()) {
            bullets.splice(i,1);
        }
    }
    
    // Update explosions
    explosions.forEach((ex, i) => { 
        ex.r += 8; 
        if(ex.r > ex.maxR) explosions.splice(i, 1); 
    });
    
    // Update burn effects
    for(let i = burns.length-1; i >= 0; i--) {
        burns[i].duration--;
        if(burns[i].duration <= 0) {
            burns.splice(i,1);
        }
    }
    
    // Update sand traps
    for(let i = sandTraps.length-1; i >= 0; i--) {
        sandTraps[i].duration--;
        if(sandTraps[i].duration <= 0) {
            sandTraps.splice(i,1);
        }
    }
    
    // Update poison clouds
    for(let i = poisonClouds.length-1; i >= 0; i--) {
        poisonClouds[i].duration--;
        if(poisonClouds[i].duration <= 0) {
            poisonClouds.splice(i,1);
        }
    }
    
    // Remove dead turrets
    for(let i = turrets.length-1; i >= 0; i--) {
        if(turrets[i].health <= 0) {
            map[turrets[i].gy][turrets[i].gx] = 0;
            turrets.splice(i,1);
            updateFlowField();
        }
    }
    
    // Wave completion check
    if(enemies.length === 0 && gameState === 'PLAYING'){ 
        gameState='EDITOR'; 
        money += farms.length * 120;
        if (core.hp < core.maxHp / 2) core.hp = core.maxHp / 2;
        document.getElementById('moneyDisplay').innerText = money; 
        wave++; 
        document.getElementById('editorUI').classList.remove('hidden'); 
        money += 500; 
        document.getElementById('moneyDisplay').innerText = money; 
    }
    
    // Game over check
    if(core.hp <= 0){ 
        alert("CORE DESTROYED AT WAVE "+wave); 
        location.reload(); 
    }
    
    // Update UI
    document.getElementById('coreHP').innerText = Math.floor(core.hp);
    document.getElementById('waveDisplay').innerText = "WAVE: " + wave;
}

function drawWorld() {
    // Draw grid
    for(let y=0; y<MAP_HEIGHT; y++) {
        for(let x=0; x<MAP_WIDTH; x++) {
            const tile = map[y][x];
            if(tile === 0) {
                ctx.strokeStyle = '#111'; 
                ctx.lineWidth = 1;
                ctx.strokeRect(x*TILE_SIZE, y*TILE_SIZE, TILE_SIZE, TILE_SIZE);
                continue;
            }
            
            ctx.fillStyle = COLORS[tile] || '#fff'; 
            ctx.fillRect(x*TILE_SIZE, y*TILE_SIZE, TILE_SIZE-1, TILE_SIZE-1);
            
            // Draw crate symbols
            if(tile >= 3 && tile <= 5) {
                ctx.fillStyle = '#fff';
                ctx.font = '16px Courier New';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                let symbol = '?';
                if(tile === TILES.CRATE_PIERCE) symbol = 'P';
                else if(tile === TILES.CRATE_HEAVY) symbol = 'H';
                else if(tile === TILES.CRATE_EXPLOSIVE) symbol = 'E';
                
                ctx.fillText(symbol, x*TILE_SIZE + TILE_SIZE/2, y*TILE_SIZE + TILE_SIZE/2);
            }
            
            // Draw air gun crate symbol
            if(tile === TILES.CRATE_AIR) {
                ctx.fillStyle = '#fff';
                ctx.font = '16px Courier New';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('A', x*TILE_SIZE + TILE_SIZE/2, y*TILE_SIZE + TILE_SIZE/2);
            }
            
            // Draw sand pattern
            if(tile === TILES.SAND) {
                ctx.fillStyle = '#da8';
                for(let i = 0; i < 4; i++) {
                    for(let j = 0; j < 4; j++) {
                        if((i+j) % 2 === 0) {
                            ctx.fillRect(
                                x*TILE_SIZE + i*10, 
                                y*TILE_SIZE + j*10, 
                                5, 5
                            );
                        }
                    }
                }
            }
            
            // Draw poison pattern
            if(tile === TILES.POISON) {
                ctx.fillStyle = '#0f0';
                ctx.globalAlpha = 0.5;
                ctx.beginPath();
                ctx.arc(
                    x*TILE_SIZE + TILE_SIZE/2, 
                    y*TILE_SIZE + TILE_SIZE/2, 
                    TILE_SIZE/3, 
                    0, Math.PI*2
                );
                ctx.fill();
                ctx.globalAlpha = 1.0;
            }
        }
    }
    
    // Draw fly traps
    flyTraps.forEach(ft => ft.draw());
    
    // Draw sand traps
    sandTraps.forEach(sand => {
        const alpha = sand.duration / sand.maxDuration;
        ctx.fillStyle = `rgba(218, 168, 136, ${alpha * 0.4})`;
        ctx.beginPath();
        ctx.arc(sand.x, sand.y, sand.radius, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.fillStyle = `rgba(218, 168, 136, ${alpha})`;
        for(let i = 0; i < 5; i++) {
            const angle = Math.random() * Math.PI * 2;
            const dist = Math.random() * sand.radius;
            const px = sand.x + Math.cos(angle) * dist;
            const py = sand.y + Math.sin(angle) * dist;
            
            ctx.beginPath();
            ctx.arc(px, py, 2, 0, Math.PI * 2);
            ctx.fill();
        }
    });
    
    // Draw poison clouds
    poisonClouds.forEach(poison => {
        const alpha = poison.duration / poison.maxDuration;
        ctx.fillStyle = `rgba(0, 255, 0, ${alpha * 0.3})`;
        ctx.beginPath();
        ctx.arc(poison.x, poison.y, poison.radius, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.fillStyle = `rgba(0, 255, 0, ${alpha})`;
        for(let i = 0; i < 3; i++) {
            const angle = Math.random() * Math.PI * 2;
            const dist = Math.random() * poison.radius;
            const px = poison.x + Math.cos(angle) * dist;
            const py = poison.y + Math.sin(angle) * dist;
            const size = 3 + Math.random() * 3;
            
            ctx.beginPath();
            ctx.arc(px, py, size, 0, Math.PI * 2);
            ctx.fill();
        }
    });
    
    // Draw burn effects
    burns.forEach(burn => {
        const alpha = burn.duration / burn.maxDuration;
        ctx.fillStyle = `rgba(255, 85, 0, ${alpha * 0.3})`;
        ctx.beginPath();
        ctx.arc(burn.x, burn.y, burn.radius, 0, Math.PI * 2);
        ctx.fill();
        
        for(let i = 0; i < 3; i++) {
            const angle = Math.random() * Math.PI * 2;
            const dist = Math.random() * burn.radius;
            const px = burn.x + Math.cos(angle) * dist;
            const py = burn.y + Math.sin(angle) * dist;
            const size = 2 + Math.random() * 3;
            
            ctx.fillStyle = `rgba(255, ${100 + Math.random() * 155}, 0, ${alpha})`;
            ctx.beginPath();
            ctx.arc(px, py, size, 0, Math.PI * 2);
            ctx.fill();
        }
    });
    
    // Draw players
    players.forEach(p=>{ 
        ctx.save(); 
        ctx.translate(p.x,p.y); 
        if(p.powerup) { 
            ctx.fillStyle = POWER_COLORS[p.powerup]; 
            ctx.font = '10px Courier New'; 
            ctx.fillText(`${p.powerup}`, -20, -25); 
        }
        ctx.rotate(p.angle); 
        ctx.fillStyle=p.id===1?'#f44':'#44f'; 
        ctx.beginPath(); 
        ctx.moveTo(15,0); 
        ctx.lineTo(-10,-10); 
        ctx.lineTo(-10,10); 
        ctx.fill(); 
        ctx.restore();
    });
    
    // Draw turrets
    turrets.forEach(t => t.draw());
    
    // Draw enemies
    enemies.forEach(en => en.draw());
    
    // Draw bullets
    bullets.forEach(b => b.draw());
    
    // Draw air bullets
    airBullets.forEach(b => b.draw());
    
    // Draw explosions
    explosions.forEach(ex => { 
        ctx.strokeStyle = `rgba(255, 100, 0, ${1 - ex.r/ex.maxR})`; 
        ctx.lineWidth=3; 
        ctx.beginPath(); 
        ctx.arc(ex.x, ex.y, ex.r, 0, Math.PI*2); 
        ctx.stroke(); 
    });
}

function render() {
    ctx.fillStyle='#050505'; 
    ctx.fillRect(0,0,canvas.width,canvas.height);
    
    if (gameState === 'PLAYING') {
        const halfW = canvas.width / 2;
        
        // P1 View
        ctx.save();
        ctx.beginPath(); 
        ctx.rect(0, 0, halfW, canvas.height); 
        ctx.clip();
        ctx.translate(halfW/2, canvas.height/2);
        ctx.scale(playerZoom, playerZoom);
        ctx.translate(-players[0].x, -players[0].y);
        drawWorld();
        ctx.restore();
        
        // P2 View
        ctx.save();
        ctx.beginPath(); 
        ctx.rect(halfW, 0, halfW, canvas.height); 
        ctx.clip();
        ctx.translate(halfW + halfW/2, canvas.height/2);
        ctx.scale(playerZoom, playerZoom);
        ctx.translate(-players[1].x, -players[1].y);
        drawWorld();
        ctx.restore();
        
        // Divider
        ctx.strokeStyle = '#555'; 
        ctx.lineWidth = 4;
        ctx.beginPath(); 
        ctx.moveTo(halfW, 0); 
        ctx.lineTo(halfW, canvas.height); 
        ctx.stroke();
    } else {
        ctx.save();
        ctx.translate(canvas.width/2, canvas.height/2);
        ctx.scale(editCam.zoom, editCam.zoom);
        ctx.translate(-editCam.x, -editCam.y);
        drawWorld();
        ctx.restore();
    }
    
    requestAnimationFrame(render);
}

// Initialize
initMap(true);
setInterval(update, 1000/60); 
render();
</script>
</body>
</html>
